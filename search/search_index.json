{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Informaci\u00f3 del m\u00f2dul","text":""},{"location":"#professorat","title":"Professorat","text":"<ul> <li>Paco Galera</li> </ul>"},{"location":"#programacio","title":"Programaci\u00f3","text":"<ul> <li>1r Desenvolupament d'Aplicacions Multiplataforma - Semipresencial (DAMsp)</li> <li>IES Jaume II el Just</li> <li>Tavernes de la Valldigna</li> <li>AULES</li> </ul>"},{"location":"#continguts","title":"Continguts","text":"<ol> <li>Dades simples. Instruccions seq\u00fcencials.</li> <li>Programaci\u00f3 estructurada. Disseny d'algorismes en Python.</li> <li>Introducci\u00f3 a Python.</li> <li>Estructures de control en Python.</li> <li>Introducci\u00f3 a Java.</li> <li>Arrays en Java i Python.</li> <li>Programaci\u00f3 modular. Funcions en Java.</li> <li>Programaci\u00f3 Orientada a Objectes. Classes amb atributs.</li> <li>Programaci\u00f3 Orientada a Objectes. Classes amb m\u00e8todes.</li> <li>Interf\u00edcies.</li> <li>Fitxers.</li> </ol>"},{"location":"PRG01/","title":"UD1. Dades simples. Instruccions seq\u00fcencials","text":""},{"location":"PRG01/#introduccio","title":"Introducci\u00f3","text":"<p>Un programa \u00e9s una seq\u00fc\u00e8ncia d\u2019instruccions que manipulen unes dades per a obtindre uns resultats.</p> <p>Eixes instruccions s\u00f3n ordres que li fem a l\u2019ordinador. Per a aix\u00f2 cal dir-li-ho en el llenguatge que ent\u00e9n, que \u00e9s el llenguatge m\u00e0quina, compost per seq\u00fc\u00e8ncies de 0s i 1s, igual que tota la informaci\u00f3 que es guarda en un ordinador (n\u00fameros, text, fotos, m\u00fasica, jocs, pel\u00b7l\u00edcules...):</p> <p>Per\u00f2 com per a nosaltres (els humans) ens resulta molt dif\u00edcil, li ho direm en altre llenguatge. Comen\u00e7arem amb Python i m\u00e9s avant vorem Java.</p> <p>En este tema vorem les dades que s\u00f3n manipulades pels programes.</p>"},{"location":"PRG01/#dades-simples","title":"Dades simples","text":"<p>Una dada \u00e9s qualsevol informaci\u00f3 amb la qual treballa un algorisme.</p> <p>Cada dada \u00e9s d'un tipus determinat que, b\u00e0sicament, ser\u00e0 enter, real, car\u00e0cter o l\u00f2gic, per\u00f2 que dependr\u00e0 del llenguatge de programaci\u00f3 en qu\u00e8 estem treballant.</p> <p>Les dades apareixen en un programa en una de les seg\u00fcents formes:</p> <ul> <li>variables</li> <li>constants (simb\u00f2liques i literals)</li> </ul>"},{"location":"PRG01/#variables","title":"Variables","text":"<p>Una variable \u00e9s un lloc on podem guardar una dada.</p> <p></p> <p>La imatge representa la variable edat, que guarda el valor 17. Cada variable es caracteritza per tindre:</p> <ul> <li>Un nom (edat) i un tipus (enter), que s'han d'especificar quan es defineix la variable en un programa, amb una instrucci\u00f3 declarativa (encara que hi ha llenguatges, com Python, que no cal indicar el tipus).</li> <li>Un valor (17), que li s'assignar\u00e0 en alguna instrucci\u00f3 d'assignaci\u00f3 (o b\u00e9 en la mateixa instrucci\u00f3 declarativa) i que podr\u00e0 ser canviat per altre valor les voltes que calga.</li> </ul> <p>Les variables s'emmagatzemen a la mem\u00f2ria RAM, de forma que:</p> <p></p> <ul> <li>El nom (edat) representa l'adre\u00e7a de la RAM on est\u00e0 el valor.</li> <li>El tipus (enter) especifica la quantitat de bytes necessaris per guardar un valor (4).</li> <li>El valor \u00e9s el contingut (17).</li> </ul> Exemple<pre><code>// instrucci\u00f3 declarativa\nint edat; // Definim una variable, de nom 'edat' i de tipus 'enter'     \n\n// instruccions d'assignaci\u00f3\nedat = 17;          // Donem valor '17' a la variable edat\nllig(edat);         // Assignem per teclat un valor a edat. Per exemple 19\nedat = edat + 3;    // Tornem a canviar el valor. Ara valdr\u00e0 22\nedat = 23.5;        // ERROR! Per qu\u00e8?\n\n// utilitzaci\u00f3 de la variable\nescriu(edat);       // Escrivim en pantalla el valor de la variable edat\n</code></pre> <p>Nota</p> <p>M\u00e9s endavant veurem estes instruccions detalladament</p>"},{"location":"PRG01/#constants","title":"Constants","text":"<p>Una constant \u00e9s com una variable per\u00f2 que el valor no canvia durant l'execuci\u00f3 del programa.</p> <p>Les constants poden apar\u00e9ixer en forma de literals o b\u00e9 amb nom (constants simb\u00f2liques):</p> <p> SIMB\u00d2LIQUES LITERALS MAX_EDAT 99 PI 3.1416 VALOR_EURO 166.386 NOM_INSTITUT \"Jaume II el Just\" CICLES_INFORMATICA true MAJORIA_EDAT 18 <p></p> <p>Les constants simb\u00f2liques, igual que les variables, tenen un valor concret que se li d\u00f3na al principi del programa per\u00f2, com ja hem dit, no poden canviar de valor.</p> <p>Les constants literals alfanum\u00e8riques han d'expressar-se tancades entre cometes.</p>"},{"location":"PRG01/#expressions","title":"Expressions","text":"<p>Les constants i variables no apareixen a\u00efllades, sin\u00f3 formant part d'expressions. Una expressi\u00f3 \u00e9s un c\u00e0lcul necessari per a obtindre un resultat.</p> <p>Una expressi\u00f3 \u00e9s una combinaci\u00f3 d'operands units mitjan\u00e7ant operadors.</p> <ul> <li>Els operands poden ser de diferents tipus:<ul> <li>Literals: \"Jaume II el Just\", 100</li> <li>Constants: PI</li> <li>Variables: edat</li> <li>Funcions: arrel(100), longitut(nom)</li> </ul> </li> <li>Els operadors els vorem en altre apartat</li> </ul> Exemples d'expressions <ul> <li> <p>Num\u00e8riques:</p> <ul> <li>edat</li> <li>5</li> <li>2 * PI * quadrat(radi)</li> <li>(-b+arrel(quadrat(b)-(4ac)))/(2*a)</li> </ul> </li> <li> <p>Alfanum\u00e8riques:</p> <ul> <li>\"Neus\"</li> <li>\"Miquel\" + \"Garcia\" + \"Marqu\u00e9s\"</li> </ul> </li> <li> <p>L\u00f2giques:</p> <ul> <li>true</li> <li>false</li> <li>valor1 &lt; valor2</li> <li>(valor1 &lt; valor2)&amp;&amp;(valor2 &lt;valor3)</li> </ul> </li> </ul>"},{"location":"PRG01/#operadors","title":"Operadors","text":"<p>S\u00f3n els s\u00edmbols de les operacions amb els quals es construeixen les expressions.</p> <p>Depenent del tipus de dades dels operands o del tipus del resultat, tenim uns tipus d'operadors: aritm\u00e8tics, l\u00f2gics, relacionals i alfanum\u00e8rics.</p>"},{"location":"PRG01/#operadors-aritmetics","title":"Operadors aritm\u00e8tics","text":"<p>S\u00f3n les operacions matem\u00e0tiques. Les variables o constants que hi intervenen s\u00f3n num\u00e8riques (enters o reals) i el resultat tamb\u00e9. Els m\u00e9s usuals s\u00f3n:</p> <p> OPERADOR SIGNIFICAT ^ Exponenciaci\u00f3 * Producte / Divisi\u00f3 % Residu de divisi\u00f3 entera + Suma - Resta <p></p>"},{"location":"PRG01/#regles-de-prioritat","title":"Regles de prioritat","text":"<p>Les expressions que tenen 2 o m\u00e9s operands necessiten unes regles que permeten determinar en quin ordre s'avaluen. Per exemple, si escrivim <code>escriu(2*5-3);</code> qu\u00e8 mostrar\u00e0? 7 o 4? La resposta \u00e9s 7, ja que les regles de prioritat indiquen que l'operador del producte t\u00e9 m\u00e9s prioritat que el de la resta, com veiem a la taula:</p> <p> OPERADOR PRIORITAT ^ ALTA *  /  % | +  - BAIXA <p></p> <p>Si dos operadors d'igual prioritat coincideixen en una mateixa expressi\u00f3, s'avaluen d'esquerra a dreta. Per\u00f2 si volgu\u00e8rem canviar l'ordre d'avaluaci\u00f3 en una expressi\u00f3, utilitzarem els par\u00e8ntesi necessaris. A banda, \u00e9s recomanable l'\u00fas de par\u00e8ntesis davant del dubte.</p>"},{"location":"PRG01/#operadors-relacionals","title":"Operadors relacionals","text":"<p>Serveixen per a comparar 2 expressions, retornant un valor l\u00f2gic: vertader o fals.</p> <p> OPERADOR SIGNIFICAT &lt; Menor &gt; Major == Igual != Distint &lt;= Menor o igual &gt;= Major o igual <p></p> Exemples d'expressions l\u00f2giques <p> Si x = 10 i y = 20: EXPRESSI\u00d3 VALOR (x + y) &lt; 20 false (y - x) &lt;= x true (y - x) &gt;= x true x == y false x != y true 'c' &lt; 'f' true * <p>* Tamb\u00e9 podem comparar car\u00e0cters (van entre cometes)</p> <p></p>"},{"location":"PRG01/#operadors-logics","title":"Operadors l\u00f2gics","text":"<p>Els operadors l\u00f2gics s\u00f3n NO, I i O. Per\u00f2 per seguir la nomenclatura est\u00e0ndard dels algorismes utilitzarem els noms anglesos: NOT, AND i OR. Act\u00faen sobre operands o expressions l\u00f2giques i el resultat tamb\u00e9 \u00e9s un valor l\u00f2gic, que ve donat per les corresponents taules de veritat*, on V \u00e9s Vertader (true) i F \u00e9s Fals (false):</p> <p> x NOT x F V V F x y x AND y F F F F V F V F F V V V x y x OR y F F F F V V V F V V V V <p></p> Exemples <p><code>NOT (3 &lt; 5)</code> -&gt; F</p> <p><code>(3 &lt; 5) AND (4 &lt; 2)</code> -&gt; F</p> <p><code>(3 &lt; 5) OR (4 &lt; 2)</code> -&gt; V</p> <p>Expressions sin\u00f2nimes</p> <p> NOT(a &lt; b) a &gt;= b NOT(a &lt;= b) a &gt; b NOT(a + b == 0) a + b != 0 Compte! No canvien els operandors aritm\u00e8tics NOT(true) false NOT(false) true NOT(jubilat == true) NOT(jubilat) jubilat == false NOT(jubilat == false) jubiat == true jubilat <p></p>"},{"location":"PRG01/#lleis-de-de-morgan","title":"Lleis de De Morgan","text":"<p>S\u00f3n regles que permeten transformar expressions l\u00f2giques en altres equivalents. S\u00f3n molt \u00fatils per a simplificar expressions condicionals. Concretament, transformen expressions formades amb un NOT sobre alguna expressi\u00f3 que t\u00e9 dins algun AND, OR o NOT.</p>"},{"location":"PRG01/#1a-llei-de-de-morgan","title":"1a llei de De Morgan","text":"<p><code>NOT(A AND B)</code> \u00e9s equivalent a <code>NOT(A) OR NOT(B)</code></p> Exemple <p>Si A \u00e9s Plou, i B \u00e9s Fa fred:</p> <p><code>NOT(A AND B)</code> significa No \u00e9s cert que ploga i fa\u00e7a fred alhora. Aix\u00f2, segons esta llei, \u00e9s equivalent a dir: <code>NOT(A) OR NOT(B)</code>, que significa No plou o no fa fred. Veiem-ho d'una altra forma, amb les variables plou i fred:</p> <p><code>NOT(plou AND fred) -&gt; NOT(plou) OR NOT(fred)</code></p> <p>\u00c9s a dir, tinguen els valors que tinguen plou i fred (verdader o fals), sempre tindrem el mateix resultat en les 2 expressions equivalents. Comprovem-ho amb la taula de veritat:</p> <p> p(plou) f(fred) p AND f NOT(p AND f) NOT(p) NOT(f) NOT(p) OR NOT(f) V V V F F F F V F F V F V V F V F V V F V F F F V V V V <p></p>"},{"location":"PRG01/#2a-llei-de-de-morgan","title":"2a llei de De Morgan","text":"<p><code>NOT(A OR B)</code> \u00e9s equivalent a <code>NOT(A) AND NOT(B)</code></p> Exemple <p>Si A \u00e9s Plou, i B \u00e9s Fa fred:</p> <p><code>NOT(A OR B)</code> significa No \u00e9s cert que: ploga o fa\u00e7ca fred. Aix\u00f2, segons esta llei, \u00e9s equivalent a dir: <code>NOT(A) AND NOT(B)</code>, que significa No plou i no fa fred. Veiem-ho ara amb les variables plou i fred:</p> <p><code>NOT(plou OR fred) -&gt; NOT(plou) AND NOT(fred)</code></p> <p>\u00c9s a dir, tinguen els valors que tinguen plou i fred (verdader o fals), sempre tindrem el mateix resultat en les 2 expressions equivalents. Comprovem-ho amb la taula de veritat:</p> <p> p(plou) f(fred) p OR f NOT(p OR f) NOT(p) NOT(f) NOT(p) AND NOT(f) V V V F F F F V F V F F V F F V V F V F F F F F V V V V <p></p>"},{"location":"PRG01/#3a-llei-de-de-morgan","title":"3a llei de De Morgan","text":"<p><code>NOT(NOT(A))</code> \u00e9s equivalent a <code>A</code></p> Exemple <p>Dir que No \u00e9s cert que no plou \u00e9s el mateix que dir que plou.</p> <p>Com aplicar estes lleis quan el NOT act\u00faa sobre m\u00e9s d'un operador l\u00f2gic?</p> <p>Per exemple:</p> <p><code>NOT(plou AND NOT(fred) AND sol AND humitat)</code></p> <p>Caldria:</p> <ul> <li>Llevar el NOT que abarca tota l'expressi\u00f3.</li> <li>Canviar els AND per OR i al rev\u00e9s.</li> <li>Posar un NOT a cada part.</li> </ul> <p>\u00c9s a dir:</p> <p><code>(NOT(plou) OR NOT(NOT(fred)) OR NOT(sol) OR NOT(humanitat))</code></p> <p>I, aplicant la llei de la doble negaci\u00f3, quedaria:</p> <p><code>NOT(plou) OR fred OR NOT(sol) OR NOT(humitat)</code></p> <p>Compte! Si en l'expressi\u00f3 que abarca el NOT hi ha ORs i ANDs (les 2 coses alhora), cal anar en compte en transformaci\u00f3, ja que, com anem a vore a continuaci\u00f3, l'AND \u00e9s m\u00e9s prioritari que l'OR. La soluci\u00f3 seria, abans de fer la transformaci\u00f3, posar els par\u00e8ntesis que calguen, i despr\u00e9s ja fer la transformaci\u00f3 conservant els par\u00e8ntesis.</p> <p>Per exemple, si tenim:</p> <p><code>NOT(plou AND fred OR sol)</code></p> <p>Primer posarem par\u00e8ntesis per tindre una soluci\u00f3 equivalent. Com l'AND \u00e9s m\u00e9s prioritari que l'OR, posarem els par\u00e9ntesi aix\u00ed:</p> <p><code>NOT((plou AND fred) OR sol)</code></p> <p>Ara ja apliquem les lleis de De Morgan, conservant els par\u00e8ntesis de dins:</p> <p><code>(NOT(plou) OR NOT(fred)) AND NOT(sol)</code></p>"},{"location":"PRG01/#regles-de-prioritat_1","title":"Regles de prioritat","text":"<p>Com els operadors l\u00f2gics i relacionals poden formar expressions juntament amb els aritm\u00e8tics, tamb\u00e9 necessitem unes regles de prioritat per a saber quins operadors s'avaluen primer.</p> <p> OPERADOR PRIORITAT NOT ALTA ^ | *, /, % | +, - | &lt;, &gt;, &lt;=, &gt;= | ==, != | AND V OR BAIXA <p></p> <p>Estes regles s\u00f3n bastant est\u00e0ndards per\u00f2 podria dependre de cada llenguatge de programaci\u00f3.</p> <p>No obstant, davant el dubte, sempre podem (i devem) emprar els par\u00e8ntesis.</p>"},{"location":"PRG01/#funcions","title":"Funcions","text":"<p>S\u00f3n trossos de codi que podem utilitzar en els nostres programes. Hi ha de 2 tipus: predefinides i definides per l'usuari.</p>"},{"location":"PRG01/#funcions-predefinides","title":"Funcions predefinides","text":"<p>Els llenguatges de programaci\u00f3 tenen funcions predefinides amb les quals podem dur a terme les tasques m\u00e9s usuals. Les funcions (igual que en les de les matem\u00e0tiques) solen rebre un o m\u00e9s arguments i retornen un valor que anoomenem resultat.</p> <p>Per exemple, per a mostrar coses per pantalla tenim:</p> <ul> <li><code>printf(\"Hola\");</code> en llenguatge C</li> <li><code>System.out.println(\"Hola\");</code> en llenguatge Java</li> <li><code>escriu(\"Hola\")</code> forma que emprarem en algorismes</li> </ul>"},{"location":"PRG01/#funcions-definides-per-lusuari","title":"Funcions definides per l'usuari","text":"<p>Podem crear funcions i usar-les en diferens parts del programa:</p> Exemple de funci\u00f3<pre><code>    Programa principal{\n        escriu(\"L'\u00e0rea del  triangle de base 2 i altura 4 \u00e9s:\");\n        area = areaTriangle(2, 4);\n        escriu(area);\n        escriu(\"L'\u00e0rea del triangle de base 3 i altura 6 \u00e9s:\" + areaTriangle(3, 6));\n    }\n\n    // -------------------------------------------------\n\n    funci\u00f3 areaTriangle(base: enter, altura: enter){\n        area real;\n        area = base * altura / 2;\n        retorna area;\n    }\n</code></pre> <p>Ja vorem en detall l'\u00fas de funcions m\u00e9s endavat...</p>"},{"location":"PRG01/#activitats","title":"Activitats","text":"Activitat 1 <p>Calcula el valor de cada expressi\u00f3 si \u00e9s v\u00e0lida. Si no \u00e9s v\u00e0lida, indica el motiu.</p> <p>a. 10 * 3 + 5 * 2</p> <p>b. 15 % 4</p> <p>c. 2 + 7 / 3</p> <p>d. 4 + \"preu\"</p> <p>e. (5 + 2) &lt; 8</p> <p>f. 4 &gt;= 4</p> <p>g. true OR false</p> <p>h. 5 OR (2 &lt; 3)</p> <p>i. (6 &gt;= 2) OR (3 &lt;= 5)</p> <p>j. NOT(NOT(NOT(4 &lt; 10&gt;)))</p> <p>k. 4 + false</p> <p>l. 4 + 2 * 4 / 2</p> <p>m. ((5 &lt; 0) AND (6 &gt;= 7)) OR (45 % 5 &lt;= 0)</p> <p>n. ((10 - 4) &gt; 0) OR true</p> <p>o. ((10 - 4) &lt; 0) OR true</p> Activitat 2 <p>Donats els seg\u00fcents valors de les variables X = 1, Y = 4, Z = 10 i la constant PI = 3.14, avalua les expressions seg\u00fcents:</p> <p>a. <code>2 * X + 0.5 * Y - 1 / 5 * Z</code></p> <p>b. <code>((PI * X ^ 2) &gt; Y) OR ((2 * PI * X) &lt;= Z)</code></p> <p>c. <code>\"Hola, m\u00f3n!\" == \"Hola,\" + \"m\u00f3n!\"</code></p> <p>d. <code>'a' == 'A'</code></p> Activitat 3 <p>Construeix expressions correctes per a les f\u00f3rmules seg\u00fcents:</p> <p></p> Activitat 4 <p>A partir de les seg\u00fcents constants:</p> <ul> <li>gran = fals</li> <li>red\u00f3 = cert</li> <li>suau = fals</li> </ul> <p>...indica quin ser\u00e0 el valor de les seg\u00fcents expressions:</p> <p>a. gran i red\u00f3 i suau;</p> <p>b. gran o red\u00f3 o suau;</p> <p>c. gran i red\u00f3 o suau;</p> <p>d. gran o red\u00f3 i suau;</p> <p>e. gran i (red\u00f3 o suau);</p> <p>f. (gran o red\u00f3) i suau;</p> Activitat 5 <p>Indica amb par\u00e8ntesis l'ordre en qu\u00e8 l'ordinador executaria les diferents operacions:</p> <p>a. x + y + z</p> <p>b. x * y + z</p> <p>c. x + y * z</p> <p>d. x - y * z</p> <p>e. x + y / z</p> <p>f. x * y / z</p> <p>g. x / y / z</p> <p>h. x / y * y + x % y</p> <p>i. x / y + z + x</p> Activitat 6 <p>Tranforma les seg\u00fcents expressions en altres equivalents utilitzant les lleis de De Morgan. Cal tindre en compte que a, b, c s\u00f3n variables enteres i p, q, r s\u00f3n variables booleanes (l\u00f2giques).</p> <p>a. <code>NOT((p AND q) OR r)</code></p> <p>b. <code>NOT((a == b) OR (a == 0))</code></p> <p>c. <code>NOT(NOT p OR NOT q OR (a == b + c))</code></p> <p>d. <code>NOT(p AND (q OR r))</code></p> <p>e. <code>NOT((a &lt; b) AND (b &lt; c))</code></p> <p>f. <code>NOT(NOT p AND q OR NOT r)</code></p> <p>g. <code>NOT(NOT(a != b) OR (a + b == 7))</code></p> <p>h. <code>NOT((a / b == 0) OR (a == c))</code></p> Activitat 7 <p>Donats els valors inicials de les seg\u00fcents variables enteres i l\u00f2giques:</p> <p><code>a = 3; b = 5; c = 7; p = cert; q = fals;</code></p> <p>... indica els valors que tindran estes variables despr\u00e9s de les seg\u00fcents assignacions.</p> <p>NOTA: en cada apartat es tindr\u00e0 en compte els canvis de les variables dels apartats anteriors.</p> <p>a. <code>a = 3 * b</code></p> <p>b. <code>b = a + c</code></p> <p>c. <code>p = p and (c &gt; b)</code></p> <p>d. <code>q = p or q</code></p> <p>e. <code>r = a == b</code></p> <p>f. <code>a = a + 1</code></p> <p>g. <code>b = b - 2</code></p> <p>h. <code>a = a</code></p> <p>i. <code>b = b / 2 + c % 3</code></p> Activitat 8 <p>Sent a, b, c i d variables num\u00e8riques, escriu l'expressi\u00f3 l\u00f2gica corresponent a:</p> <p>a. Els valors de b i c s\u00f3n tots dos superiors al valor de d</p> <p>b. a, b i c s\u00f3n id\u00e8ntics</p> <p>c. a, b i c s\u00f3n id\u00e8ntics per\u00f2 diferents de d</p> <p>d. b est\u00e0 compr\u00e9s, estrictament, entre els valors de a i c</p> <p>e. b est\u00e0 comrpr\u00e9s, estrictament, entre els valors de a i c, i el valor de a \u00e9s m\u00e9s xicotet que el valor de c</p> <p>f. Hi ha, com a m\u00ednim, dos valors id\u00e8ntics entre a, b i c</p> <p>g. Hi ha dos valors id\u00e8ntics entre a, b i c, i nom\u00e9s dos</p> <p>h. Hi ha, com a m\u00e0xim, dos valors id\u00e8ntics entre a, b i c</p> Activitat 9 <p>Escriu l'expressi\u00f3 algor\u00edsmica de les seg\u00fcents expressions:</p> <p>a. Avaluar si el contingut d'una variable num\u00e8rica \u00e9s divisible per 10 o per 7</p> <p>b. Avaluar si una variable preu no \u00e9s menor de 100\u00bd ni major de 200\u20ac</p> Activitat 10 <p>Si DN, MN, AN representen el dia, mes i any d'una persona i DA, MA, AA el dia, mes i any actuals, expresssa amb una expressi\u00f3 si la persona ha complit 18 anys.</p> Activitat 11 <p>En un algorisme que analitza els resultats d'ex\u00e0mens, hi ha 5 variables definides:</p> Java<pre><code>char opcio;             // Tipus d'alumne: (C)i\u00e8ncies o (L)letres\nint nl, nv, nm, nf;     // Notes de literatura, valenci\u00e0, mate i f\u00edsica d'un alumne\n</code></pre> <p>Totes les notes estan calculades sobre 10 i tenen el mateix pes per a fer la mitjana.</p> <p>Escriu les expressions l\u00f2giques corresponents a:</p> <p>a. La mitjana de les quatre notes \u00e9s superior a 5</p> <p>b. Les notes de mate i valenci\u00e0 s\u00f3n superiors a la mitjana de les quatre notes</p> <p>c. Hi ha, com a m\u00ednim, una nota superior a 5</p> <p>d. Totes les notes s\u00f3n superiors a 5</p> <p>e. La mitjana de les quatre notes \u00e9s superior o igual a 5, i la mitjana de les notes de l'opci\u00f3 que ha agafat l'alumne tamb\u00e9</p>"},{"location":"PRG02/","title":"UD2. Programaci\u00f3 estructurada. Disseny d'algorismes en Python","text":""},{"location":"PRG02/#concepte-de-programacio-estructurada","title":"Concepte de programaci\u00f3 estructurada","text":"<p>\u00c9s unconjunt de t\u00e8cniques de programaci\u00f3 que incorporen:</p> <ul> <li>Disseny descendent: t\u00e8cnica consistent en descompondre successivament accions complexes en accions m\u00e9s simples. Divideix i vencer\u00e0s. Funcions.</li> <li>Estructures de control: descriuen el flux d'execuci\u00f3 d'una successi\u00f3 d'accions:<ul> <li>Seq\u00fcencial: s'executen les ordres de dalt cap a baix.</li> <li>Bifurcaci\u00f3: executar un o altre conjunt d'instruccions, depenent d'alguna condici\u00f3.</li> <li>Repetici\u00f3 (o bucle): repetir un conjunt d'instruccions mentre es complisca una condici\u00f3.</li> </ul> </li> </ul>"},{"location":"PRG02/#algorismes","title":"Algorismes","text":"<p>Igual que abans de fer una casa conv\u00e9 primer fer els pl\u00e0nols, per a fer un programa (mitjanament llarg) cal descriure els passos a fer, independentment del llenguatge de programaci\u00f3 que es vol utilitzar. Eixe conjunt de passos vindria a ser l'algorisme. Veiem una definici\u00f3 formal.</p>"},{"location":"PRG02/#que-es-un-algorisme","title":"Qu\u00e8 \u00e9s un algorisme?","text":"<p>\u00c9s una descripci\u00f3 clara i no ambigua de les accions necess\u00e0ries per a solucionar un problema en un ordre determinat. \u00c9s com un programa per\u00f2 no est\u00e0 escrit en cap llenguatge de programaci\u00f3 en concret. Serveix per a indicar els distints passos que ha de tindre el programa sense entrar en detall.</p>"},{"location":"PRG02/#quins-elements-te-un-algorisme","title":"Quins elements t\u00e9 un algorisme?","text":"<ul> <li>Instruccions: d'entrada, d'eixida i d'assignaci\u00f3.</li> <li>Estructures de control: bifurcacions i repeticions.</li> </ul>"},{"location":"PRG02/#com-es-fa-un-algorisme","title":"Com es fa un algorisme?","text":"<p>Per expressar un algorisme es poden utilitzar diverses metodologies. Estes s\u00f3n les m\u00e9s comunes:</p> <ul> <li>Llenguatge natural o informal: com en una recepta de cuina.</li> <li>Pseudocodi: combinaci\u00f3 entre llenguatge natural i llenguatge de programaci\u00f3.</li> <li>Ordinograma (diagrama de flux): representaci\u00f3 gr\u00e0fica on hi ha uns s\u00edmbols (accions) units per fletxes (que indiquen l'ordre d'execuci\u00f3).</li> </ul> Exemple <p>Volem fer un programa que calcule l'\u00e0rea d'un cercle a partir del radi que s'introduir\u00e0 per teclat (si el radi no \u00e9s negatiu).</p> <p>Independentment del llenguatge que utilitzarem, podem descriure els passos que caldria fer. Veiem com seria l'algorisme en cadascuna de les 3 metodologies:</p> <p>LLENGUATGE NATURAL O INFORMAL:</p> <ol> <li>Demanar el radi per teclat.</li> <li>Si el radi \u00e9s positiu, calcular l'\u00e0rea i mostrar-la.</li> <li>Si no, mostrar un missatge d'error.</li> </ol> <p>PSEUDOCODI:</p> <pre><code>Algortimo areaCercleOK\n    Escribir \"Dis-me el radi:\"\n    Leer radi\n    si radi &gt; 0 Entonces\n        area = 3.14 * radi * radi\n        Escribir \"Area = \", area\n    Sino\n        Escribir \"Radi incorrecte\"\n    FinSi\nFinAlgoritmo\n</code></pre> <p>Podem usar qualsevol altre nom per a les accions (en compte d'escribir, leer, etc...)</p> <p>Per\u00f2 ac\u00ed s'han usat eixos noms perqu\u00e8 \u00e9s la sintaxi que usa l'aplicaci\u00f3 Pseint (pseudo int\u00e8rpret d'algorismes), on podrem executar els algorismes (per si volgu\u00e9rem comprovar-ne el resultat).</p> <p>PSEINT</p> <p>ORDINOGRAMA (DIAGRAMA DE FLUX):</p> <p></p> <p>Amb PSeInt podem construir f\u00e0cilment este ordinograma a base d'anar posant eixes \"caixetes\". Tamb\u00e9 podrem executar-lo.</p> <p>PSeInt tamb\u00e9 permet convertir un ordinograma a pseudocodi (o un pseudocodi a ordinograma). I tamb\u00e9 podem exportar l'algorisme a un fitxer en Python a altre llenguatge.</p>"},{"location":"PRG02/#qualitat-dun-algorisme","title":"Qualitat d'un algorisme","text":"<p>Per a resoldre un problema determinat hi pot haver infinitat d'algorismes. La qualitat d'un algorisme dep\u00e9n de:</p> <ul> <li>Correctesa: l'algorisme ha de produir el resultat correcte per a tots els inputs possibles.</li> <li>Efici\u00e8ncia: cal minimitzar els recursos de temps i mem\u00f2ria. Sobretot per a dades d'entrada \"grans\".</li> <li>Senzillesa: l'algorisme ha de ser el m\u00e9s senzill possible, sempre que siga f\u00e0cil d'entendre i modificar.</li> </ul> <p>Estes qualitats ajuden a assegurar que un algorisme no nom\u00e9s resol el problema plantejat, sin\u00f3 que tamb\u00e9 ho fa de manera fiable, eficient i clara.</p>"},{"location":"PRG02/#elements-dun-algorisme","title":"Elements d'un algorisme","text":"<p>Els elements d'un algorisme s\u00f3n un conjunt d'instruccions, de diferents tipus:</p> <ul> <li>Instruccions d'entrada i d'eixida: per a interaccionar amb l'usuari (introduir dades al programa o que aquest mostre resultats).</li> <li>Instruccions d'assignaci\u00f3: per a decidir si s'executen un conjunt d'instruccions o unes altres.</li> <li>Instruccions de repetici\u00f3: per a repetir un conjunt d'instruccions.</li> </ul> <p>Anem a vore en detall en qu\u00e8 consisteix cadascuna d'aquestes instruccions.</p>"},{"location":"PRG02/#instruccions-dentrada-i-deixida","title":"Instruccions d'entrada i d'eixida","text":"<p>Servixen perqu\u00e8 el programa intercanvie informaci\u00f3 amb un medi extern (generalment teclat i pantalla).</p> <ul> <li>Entrada (o lectura): es demana un valor per teclat (o pel ratol\u00ed, o des d'un fitxer o base de dades) per a guardar-lo en una variable (generalment).</li> <li>Eixida (o escriptura): es mostra una dada (una constant o el valor d'una variable o el resultat d'una expressi\u00f3) per pantalla (o per impressora o la deixar\u00e0 en un fitxer o base de dades...).</li> </ul> <p>Per a vore un exemple d'instruccions d'entrada i d'eixida, veiem com podria ser un algorisme que demane per teclat el radi d'una circumfer\u00e8ncia i mostre l'\u00e0rea corresponent.</p> <p></p> <p>Per iniciar-se en la programaci\u00f3, moltes vegades conv\u00e9 fer \u00fas dels ordinogrames (sobretot quan vejam bifurcacions complexes, etc). Per tant, recomanem l'aplicaci\u00f3 del PSeInt per tal de comprovar si l'algorisme funciona.</p> <p>Ara b\u00e9, si volem fer l'algorisme en pseudocodi, quasi que \u00e9s millor fer-ho ja en un llenguatge de programaci\u00f3 que s'utilitze (no t\u00e9 sentit aprendre la sintaxi del PSeInt).</p> <p>Per tant, anirem veient els distints elements en ordinograma i en Python.</p> <p>Veiem com podria ser la implementaci\u00f3 en Python d'este algorisme que hem vist:</p> Python<pre><code>print (\"Dis-me el radi: \")  // Mostra la pantalla\nradi = int(input()) // Llig text, els converteix a enter i el guarda en la variable 'radi'\nprint(\"\u00c0rea: \", 3.14 * radi * radi) // Mostra el text \"Area\" i el resultat del c\u00e0lcul\n</code></pre> <p>Una altra forma:</p> Python<pre><code>import math // Importem la llibreria per a usar un valor de pi m\u00e9s aproximat\nradi = int(input(\"Dis-me el radi: \"))   // Mostra text, llig valor per teclat, el converteix a enter i el guarda en 'radi'\nprint(\"\u00c0rea: \", math.pi * radi ** 2)    // Mostra el resultat. En Python la pot\u00e8ncia es fa amb **\n</code></pre> <p>Nota</p> <ul> <li>Per fer un ordinograma i poder-lo provar podem usar PSeInt:<ul> <li>PSEINT</li> </ul> </li> <li>Per a programar online en Python:<ul> <li>ONLINEGDB<ul> <li>Es tracta d'un int\u00e8roret online, on nom\u00e9s hem de seleccionar el llenguatge Python3, escriure codi i polsar RUN. I, si volem guardar els programes, ens hem d'enregistrar.</li> </ul> </li> </ul> </li> <li>Per a programar en local en Python:<ul> <li>THONNY<ul> <li>Es tracta d'un IDE molt senzill per a programar en Python. Ve integrat amb ell el propi Python i amb una \u00fanica instal\u00b7laci\u00f3 podem comen\u00e7ar a crear els nostres primers programes. Recomanat!</li> </ul> </li> </ul> </li> </ul> <p>Al tema seg\u00fcent ja vorem altres alternatives com VSCode.</p> Exercici 1. Instruccions d'entrada i d'eixida <p>Demana 2 n\u00fameros per teclat i mostra la seua suma, resta, multipliaci\u00f3 i dividisi\u00f3. Fes-ho de dues maneres: ordinograma (PSeInt) i en Python (OnlineGDB).</p>"},{"location":"PRG02/#instruccions-dassignacio","title":"Instruccions d'assignaci\u00f3","text":"<p>Una assignaci\u00f3 consisteix en guardar un valor en una variable.</p> <p></p> <p>En la primera instrucci\u00f3 de l'exemple anterior, est\u00e0 posant el valor 5 dins de la variable nota1. En la segona instrucci\u00f3 posa un 7 en la variable nota2. I en la tercera, suma les dos variables, les divideix entre 2 i el resultat el posa dins de la variable notaMitja.</p> <p>\u00c9s a dir, una assignaci\u00f3 consta de 2 parts separades per un operador d'assignaci\u00f3. Sol emprar-se l'operador \"=\" (en PSeInt \u00e9s una fletxa cap a l'esquerra: \"&lt;-\"):</p> <p></p> <p>Cal tindre en compte que les assignacions NO s\u00f3n equacions matem\u00e0tiques.</p> <p>Exemple</p> <p><code>x = x + 1</code> no t'e sentit com a equaci\u00f3 per\u00f2 s\u00ed com a instrucci\u00f3 en un algorisme. \u00c9s el que anomenem un increment de la variable. En eixa instrucci\u00f3 se li assigna a la variable num\u00e8rica x un valor que correspon al valor que tenia abans eixa variable m\u00e9s una unitat.</p> Exercici 2. Instruccions d'assignaci\u00f3 <p>Fes l'algorisme amb un ordinograma o amb Python per a calcular el sou d'un treballador:</p> <ul> <li>Demana per teclat el nom del treballador, la quantitat de hores que ha treballa i el preu per hora que paga l'empresa.</li> <li>Cal tenir en compte que la retenci\u00f3 aplicada \u00e9s del 15%.</li> <li>Calcula el sou brut (import que paga l'empresa), l'import retingut (import que s'emporta hisenda) i el sou net (import que s'emporta el treballador).</li> <li>Mostra per pantalla el nom del treballador i les dades calculades abans.</li> </ul>"}]}