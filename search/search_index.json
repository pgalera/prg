{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Informaci\u00f3 del m\u00f2dul","text":""},{"location":"#professorat","title":"Professorat","text":"<ul> <li>Paco Galera</li> </ul>"},{"location":"#programacio","title":"Programaci\u00f3","text":"<ul> <li>1r Desenvolupament d'Aplicacions Multiplataforma - Semipresencial (DAMsp)</li> <li>IES Jaume II el Just</li> <li>Tavernes de la Valldigna</li> <li>AULES</li> </ul>"},{"location":"#continguts","title":"Continguts","text":"<ol> <li>Dades simples. Instruccions seq\u00fcencials.</li> <li>Programaci\u00f3 estructurada. Disseny d'algorismes en Python.</li> <li>Introducci\u00f3 a Python.</li> <li>Estructures de control en Python.</li> <li>Introducci\u00f3 a Java.</li> <li>Arrays en Java i Python.</li> <li>Programaci\u00f3 modular. Funcions en Java.</li> <li>Programaci\u00f3 Orientada a Objectes. Classes amb atributs.</li> <li>Programaci\u00f3 Orientada a Objectes. Classes amb m\u00e8todes.</li> <li>Interf\u00edcies.</li> <li>Fitxers.</li> </ol>"},{"location":"PRG01/","title":"UD1. Dades simples. Instruccions seq\u00fcencials","text":"<p>DESCARREGA LA TEORIA I ACTIVITATS EN PDF</p>"},{"location":"PRG01/#introduccio","title":"Introducci\u00f3","text":"<p>Un programa \u00e9s una seq\u00fc\u00e8ncia d\u2019instruccions que manipulen unes dades per a obtindre uns resultats.</p> <p>Eixes instruccions s\u00f3n ordres que li fem a l\u2019ordinador. Per a aix\u00f2 cal dir-li-ho en el llenguatge que ent\u00e9n, que \u00e9s el llenguatge m\u00e0quina, compost per seq\u00fc\u00e8ncies de 0s i 1s, igual que tota la informaci\u00f3 que es guarda en un ordinador (n\u00fameros, text, fotos, m\u00fasica, jocs, pel\u00b7l\u00edcules...):</p> <p>Per\u00f2 com per a nosaltres (els humans) ens resulta molt dif\u00edcil, li ho direm en altre llenguatge. Comen\u00e7arem amb Python i m\u00e9s avant vorem Java.</p> <p>En este tema vorem les dades que s\u00f3n manipulades pels programes.</p>"},{"location":"PRG01/#dades-simples","title":"Dades simples","text":"<p>Una dada \u00e9s qualsevol informaci\u00f3 amb la qual treballa un algorisme.</p> <p>Cada dada \u00e9s d'un tipus determinat que, b\u00e0sicament, ser\u00e0 enter, real, car\u00e0cter o l\u00f2gic, per\u00f2 que dependr\u00e0 del llenguatge de programaci\u00f3 en qu\u00e8 estem treballant.</p> <p>Les dades apareixen en un programa en una de les seg\u00fcents formes:</p> <ul> <li>variables</li> <li>constants (simb\u00f2liques i literals)</li> </ul>"},{"location":"PRG01/#variables","title":"Variables","text":"<p>Una variable \u00e9s un lloc on podem guardar una dada.</p> <p></p> <p>La imatge representa la variable edat, que guarda el valor 17. Cada variable es caracteritza per tindre:</p> <ul> <li>Un nom (edat) i un tipus (enter), que s'han d'especificar quan es defineix la variable en un programa, amb una instrucci\u00f3 declarativa (encara que hi ha llenguatges, com Python, que no cal indicar el tipus).</li> <li>Un valor (17), que li s'assignar\u00e0 en alguna instrucci\u00f3 d'assignaci\u00f3 (o b\u00e9 en la mateixa instrucci\u00f3 declarativa) i que podr\u00e0 ser canviat per altre valor les voltes que calga.</li> </ul> <p>Les variables s'emmagatzemen a la mem\u00f2ria RAM, de forma que:</p> <p></p> <ul> <li>El nom (edat) representa l'adre\u00e7a de la RAM on est\u00e0 el valor.</li> <li>El tipus (enter) especifica la quantitat de bytes necessaris per guardar un valor (4).</li> <li>El valor \u00e9s el contingut (17).</li> </ul> Exemple<pre><code>// instrucci\u00f3 declarativa\nint edat; // Definim una variable, de nom 'edat' i de tipus 'enter'     \n\n// instruccions d'assignaci\u00f3\nedat = 17;          // Donem valor '17' a la variable edat\nllig(edat);         // Assignem per teclat un valor a edat. Per exemple 19\nedat = edat + 3;    // Tornem a canviar el valor. Ara valdr\u00e0 22\nedat = 23.5;        // ERROR! Per qu\u00e8?\n\n// utilitzaci\u00f3 de la variable\nescriu(edat);       // Escrivim en pantalla el valor de la variable edat\n</code></pre> <p>Nota</p> <p>M\u00e9s endavant veurem estes instruccions detalladament</p>"},{"location":"PRG01/#constants","title":"Constants","text":"<p>Una constant \u00e9s com una variable per\u00f2 que el valor no canvia durant l'execuci\u00f3 del programa.</p> <p>Les constants poden apar\u00e9ixer en forma de literals o b\u00e9 amb nom (constants simb\u00f2liques):</p> <p> SIMB\u00d2LIQUES LITERALS MAX_EDAT 99 PI 3.1416 VALOR_EURO 166.386 NOM_INSTITUT \"Jaume II el Just\" CICLES_INFORMATICA true MAJORIA_EDAT 18 <p></p> <p>Les constants simb\u00f2liques, igual que les variables, tenen un valor concret que se li d\u00f3na al principi del programa per\u00f2, com ja hem dit, no poden canviar de valor.</p> <p>Les constants literals alfanum\u00e8riques han d'expressar-se tancades entre cometes.</p>"},{"location":"PRG01/#expressions","title":"Expressions","text":"<p>Les constants i variables no apareixen a\u00efllades, sin\u00f3 formant part d'expressions. Una expressi\u00f3 \u00e9s un c\u00e0lcul necessari per a obtindre un resultat.</p> <p>Una expressi\u00f3 \u00e9s una combinaci\u00f3 d'operands units mitjan\u00e7ant operadors.</p> <ul> <li>Els operands poden ser de diferents tipus:<ul> <li>Literals: \"Jaume II el Just\", 100</li> <li>Constants: PI</li> <li>Variables: edat</li> <li>Funcions: arrel(100), longitut(nom)</li> </ul> </li> <li>Els operadors els vorem en altre apartat</li> </ul> Exemples d'expressions <ul> <li> <p>Num\u00e8riques:</p> <ul> <li>edat</li> <li>5</li> <li>2 * PI * quadrat(radi)</li> <li>(-b+arrel(quadrat(b)-(4ac)))/(2*a)</li> </ul> </li> <li> <p>Alfanum\u00e8riques:</p> <ul> <li>\"Neus\"</li> <li>\"Miquel\" + \"Garcia\" + \"Marqu\u00e9s\"</li> </ul> </li> <li> <p>L\u00f2giques:</p> <ul> <li>true</li> <li>false</li> <li>valor1 &lt; valor2</li> <li>(valor1 &lt; valor2)&amp;&amp;(valor2 &lt;valor3)</li> </ul> </li> </ul>"},{"location":"PRG01/#operadors","title":"Operadors","text":"<p>S\u00f3n els s\u00edmbols de les operacions amb els quals es construeixen les expressions.</p> <p>Depenent del tipus de dades dels operands o del tipus del resultat, tenim uns tipus d'operadors: aritm\u00e8tics, l\u00f2gics, relacionals i alfanum\u00e8rics.</p>"},{"location":"PRG01/#operadors-aritmetics","title":"Operadors aritm\u00e8tics","text":"<p>S\u00f3n les operacions matem\u00e0tiques. Les variables o constants que hi intervenen s\u00f3n num\u00e8riques (enters o reals) i el resultat tamb\u00e9. Els m\u00e9s usuals s\u00f3n:</p> <p> OPERADOR SIGNIFICAT ^ Exponenciaci\u00f3 * Producte / Divisi\u00f3 % Residu de divisi\u00f3 entera + Suma - Resta <p></p>"},{"location":"PRG01/#regles-de-prioritat","title":"Regles de prioritat","text":"<p>Les expressions que tenen 2 o m\u00e9s operands necessiten unes regles que permeten determinar en quin ordre s'avaluen. Per exemple, si escrivim <code>escriu(2*5-3);</code> qu\u00e8 mostrar\u00e0? 7 o 4? La resposta \u00e9s 7, ja que les regles de prioritat indiquen que l'operador del producte t\u00e9 m\u00e9s prioritat que el de la resta, com veiem a la taula:</p> <p> OPERADOR PRIORITAT ^ ALTA *  /  % | +  - BAIXA <p></p> <p>Si dos operadors d'igual prioritat coincideixen en una mateixa expressi\u00f3, s'avaluen d'esquerra a dreta. Per\u00f2 si volgu\u00e8rem canviar l'ordre d'avaluaci\u00f3 en una expressi\u00f3, utilitzarem els par\u00e8ntesi necessaris. A banda, \u00e9s recomanable l'\u00fas de par\u00e8ntesis davant del dubte.</p>"},{"location":"PRG01/#operadors-relacionals","title":"Operadors relacionals","text":"<p>Serveixen per a comparar 2 expressions, retornant un valor l\u00f2gic: vertader o fals.</p> <p> OPERADOR SIGNIFICAT &lt; Menor &gt; Major == Igual != Distint &lt;= Menor o igual &gt;= Major o igual <p></p> Exemples d'expressions l\u00f2giques <p> Si x = 10 i y = 20: EXPRESSI\u00d3 VALOR (x + y) &lt; 20 false (y - x) &lt;= x true (y - x) &gt;= x true x == y false x != y true 'c' &lt; 'f' true * <p>* Tamb\u00e9 podem comparar car\u00e0cters (van entre cometes)</p> <p></p>"},{"location":"PRG01/#operadors-logics","title":"Operadors l\u00f2gics","text":"<p>Els operadors l\u00f2gics s\u00f3n NO, I i O. Per\u00f2 per seguir la nomenclatura est\u00e0ndard dels algorismes utilitzarem els noms anglesos: NOT, AND i OR. Act\u00faen sobre operands o expressions l\u00f2giques i el resultat tamb\u00e9 \u00e9s un valor l\u00f2gic, que ve donat per les corresponents taules de veritat*, on V \u00e9s Vertader (true) i F \u00e9s Fals (false):</p> <p> x NOT x F V V F x y x AND y F F F F V F V F F V V V x y x OR y F F F F V V V F V V V V <p></p> Exemples <p><code>NOT (3 &lt; 5)</code> -&gt; F</p> <p><code>(3 &lt; 5) AND (4 &lt; 2)</code> -&gt; F</p> <p><code>(3 &lt; 5) OR (4 &lt; 2)</code> -&gt; V</p> <p>Expressions sin\u00f2nimes</p> <p> NOT(a &lt; b) a &gt;= b NOT(a &lt;= b) a &gt; b NOT(a + b == 0) a + b != 0 Compte! No canvien els operandors aritm\u00e8tics NOT(true) false NOT(false) true NOT(jubilat == true) NOT(jubilat) jubilat == false NOT(jubilat == false) jubiat == true jubilat <p></p>"},{"location":"PRG01/#lleis-de-de-morgan","title":"Lleis de De Morgan","text":"<p>S\u00f3n regles que permeten transformar expressions l\u00f2giques en altres equivalents. S\u00f3n molt \u00fatils per a simplificar expressions condicionals. Concretament, transformen expressions formades amb un NOT sobre alguna expressi\u00f3 que t\u00e9 dins algun AND, OR o NOT.</p>"},{"location":"PRG01/#1a-llei-de-de-morgan","title":"1a llei de De Morgan","text":"<p><code>NOT(A AND B)</code> \u00e9s equivalent a <code>NOT(A) OR NOT(B)</code></p> Exemple <p>Si A \u00e9s Plou, i B \u00e9s Fa fred:</p> <p><code>NOT(A AND B)</code> significa No \u00e9s cert que ploga i fa\u00e7a fred alhora. Aix\u00f2, segons esta llei, \u00e9s equivalent a dir: <code>NOT(A) OR NOT(B)</code>, que significa No plou o no fa fred. Veiem-ho d'una altra forma, amb les variables plou i fred:</p> <p><code>NOT(plou AND fred) -&gt; NOT(plou) OR NOT(fred)</code></p> <p>\u00c9s a dir, tinguen els valors que tinguen plou i fred (verdader o fals), sempre tindrem el mateix resultat en les 2 expressions equivalents. Comprovem-ho amb la taula de veritat:</p> <p> p(plou) f(fred) p AND f NOT(p AND f) NOT(p) NOT(f) NOT(p) OR NOT(f) V V V F F F F V F F V F V V F V F V V F V F F F V V V V <p></p>"},{"location":"PRG01/#2a-llei-de-de-morgan","title":"2a llei de De Morgan","text":"<p><code>NOT(A OR B)</code> \u00e9s equivalent a <code>NOT(A) AND NOT(B)</code></p> Exemple <p>Si A \u00e9s Plou, i B \u00e9s Fa fred:</p> <p><code>NOT(A OR B)</code> significa No \u00e9s cert que: ploga o fa\u00e7ca fred. Aix\u00f2, segons esta llei, \u00e9s equivalent a dir: <code>NOT(A) AND NOT(B)</code>, que significa No plou i no fa fred. Veiem-ho ara amb les variables plou i fred:</p> <p><code>NOT(plou OR fred) -&gt; NOT(plou) AND NOT(fred)</code></p> <p>\u00c9s a dir, tinguen els valors que tinguen plou i fred (verdader o fals), sempre tindrem el mateix resultat en les 2 expressions equivalents. Comprovem-ho amb la taula de veritat:</p> <p> p(plou) f(fred) p OR f NOT(p OR f) NOT(p) NOT(f) NOT(p) AND NOT(f) V V V F F F F V F V F F V F F V V F V F F F F F V V V V <p></p>"},{"location":"PRG01/#3a-llei-de-de-morgan","title":"3a llei de De Morgan","text":"<p><code>NOT(NOT(A))</code> \u00e9s equivalent a <code>A</code></p> Exemple <p>Dir que No \u00e9s cert que no plou \u00e9s el mateix que dir que plou.</p> <p>Com aplicar estes lleis quan el NOT act\u00faa sobre m\u00e9s d'un operador l\u00f2gic?</p> <p>Per exemple:</p> <p><code>NOT(plou AND NOT(fred) AND sol AND humitat)</code></p> <p>Caldria:</p> <ul> <li>Llevar el NOT que abarca tota l'expressi\u00f3.</li> <li>Canviar els AND per OR i al rev\u00e9s.</li> <li>Posar un NOT a cada part.</li> </ul> <p>\u00c9s a dir:</p> <p><code>(NOT(plou) OR NOT(NOT(fred)) OR NOT(sol) OR NOT(humanitat))</code></p> <p>I, aplicant la llei de la doble negaci\u00f3, quedaria:</p> <p><code>NOT(plou) OR fred OR NOT(sol) OR NOT(humitat)</code></p> <p>Compte! Si en l'expressi\u00f3 que abarca el NOT hi ha ORs i ANDs (les 2 coses alhora), cal anar en compte en transformaci\u00f3, ja que, com anem a vore a continuaci\u00f3, l'AND \u00e9s m\u00e9s prioritari que l'OR. La soluci\u00f3 seria, abans de fer la transformaci\u00f3, posar els par\u00e8ntesis que calguen, i despr\u00e9s ja fer la transformaci\u00f3 conservant els par\u00e8ntesis.</p> <p>Per exemple, si tenim:</p> <p><code>NOT(plou AND fred OR sol)</code></p> <p>Primer posarem par\u00e8ntesis per tindre una soluci\u00f3 equivalent. Com l'AND \u00e9s m\u00e9s prioritari que l'OR, posarem els par\u00e9ntesi aix\u00ed:</p> <p><code>NOT((plou AND fred) OR sol)</code></p> <p>Ara ja apliquem les lleis de De Morgan, conservant els par\u00e8ntesis de dins:</p> <p><code>(NOT(plou) OR NOT(fred)) AND NOT(sol)</code></p>"},{"location":"PRG01/#regles-de-prioritat_1","title":"Regles de prioritat","text":"<p>Com els operadors l\u00f2gics i relacionals poden formar expressions juntament amb els aritm\u00e8tics, tamb\u00e9 necessitem unes regles de prioritat per a saber quins operadors s'avaluen primer.</p> <p> OPERADOR PRIORITAT NOT ALTA ^ | *, /, % | +, - | &lt;, &gt;, &lt;=, &gt;= | ==, != | AND V OR BAIXA <p></p> <p>Estes regles s\u00f3n bastant est\u00e0ndards per\u00f2 podria dependre de cada llenguatge de programaci\u00f3.</p> <p>No obstant, davant el dubte, sempre podem (i devem) emprar els par\u00e8ntesis.</p>"},{"location":"PRG01/#funcions","title":"Funcions","text":"<p>S\u00f3n trossos de codi que podem utilitzar en els nostres programes. Hi ha de 2 tipus: predefinides i definides per l'usuari.</p>"},{"location":"PRG01/#funcions-predefinides","title":"Funcions predefinides","text":"<p>Els llenguatges de programaci\u00f3 tenen funcions predefinides amb les quals podem dur a terme les tasques m\u00e9s usuals. Les funcions (igual que en les de les matem\u00e0tiques) solen rebre un o m\u00e9s arguments i retornen un valor que anoomenem resultat.</p> <p>Per exemple, per a mostrar coses per pantalla tenim:</p> <ul> <li><code>printf(\"Hola\");</code> en llenguatge C</li> <li><code>System.out.println(\"Hola\");</code> en llenguatge Java</li> <li><code>escriu(\"Hola\")</code> forma que emprarem en algorismes</li> </ul>"},{"location":"PRG01/#funcions-definides-per-lusuari","title":"Funcions definides per l'usuari","text":"<p>Podem crear funcions i usar-les en diferens parts del programa:</p> Exemple de funci\u00f3<pre><code>    Programa principal{\n        escriu(\"L'\u00e0rea del  triangle de base 2 i altura 4 \u00e9s:\");\n        area = areaTriangle(2, 4);\n        escriu(area);\n        escriu(\"L'\u00e0rea del triangle de base 3 i altura 6 \u00e9s:\" + areaTriangle(3, 6));\n    }\n\n    // -------------------------------------------------\n\n    funci\u00f3 areaTriangle(base: enter, altura: enter){\n        area real;\n        area = base * altura / 2;\n        retorna area;\n    }\n</code></pre> <p>Ja vorem en detall l'\u00fas de funcions m\u00e9s endavat...</p>"}]}